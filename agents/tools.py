# tools.py
from langchain_core.tools import tool, StructuredTool
from pydantic import BaseModel, Field
from services.tsp_algorithm import optimize_distance_tour
from services.flight_picking import get_flights as get_flights_service # Renamed import
import json
import traceback
from typing import List, Optional, Dict, Any # Added Optional, List, Dict, Any

class SpecificStop(BaseModel):
    name: str = Field(description="Name of the place or activity.")
    day: int = Field(description="The day number in the itinerary to visit this place (e.g., 1 for Day 1, 2 for Day 2).")
    time_of_day: str = Field(description="Preferred time to visit, e.g., 'morning', 'afternoon', 'evening'.")
    address: Optional[str] = Field(default=None, description="Optional. Address for custom locations if not a well-known attraction in Da Nang. This helps in identifying the place if it's not in the pre-defined list.")

class TravelPlanArgs(BaseModel):
    travel_duration: str = Field(description="The duration of the trip, e.g., '3 days 2 nights', '1 week', '5 ngay 4 dem'.")
    user_specified_stops: Optional[List[SpecificStop]] = Field(default=None, description="Optional list of specific stops the user wants to include in the plan. Each stop should specify the name, day, and time_of_day. Include an address for custom locations.")

@tool("plan_da_nang_trip", args_schema=TravelPlanArgs)
def plan_da_nang_trip_tool(travel_duration: str, user_specified_stops: Optional[List[SpecificStop]] = None) -> str:
    """
    Plans a travel itinerary for Da Nang based on a specified duration.
    It can optionally incorporate a list of user-specified stops at particular days and times.

    The tool generates a base plan using its standard algorithm for the given duration.
    If user_specified_stops are provided (e.g., 'Ba Na Hills on day 1 morning', 'Fahasa bookstore on day 2 evening with address ...'),
    these will be included in the output alongside the base plan.

    The response will be a JSON string containing:
    - 'base_plan': The itinerary generated by the standard algorithm.
    - 'user_specified_stops': A list of the specific stops requested by the user (if any).
    - 'notes': Important information regarding the plan, especially how user-specified stops are handled
               (e.g., they are requests to be considered, and custom stops' details depend on provided info).
               For custom stops not in the known Da Nang database, their integration into routing or detailed
               descriptions might be limited to the information provided (like an address).
    """
    print(f"--- Calling Planner Tool with duration: {travel_duration} and {len(user_specified_stops) if user_specified_stops else 0} specific stops ---")
    
    # Serialize SpecificStop objects to dicts for JSON compatibility
    serialized_user_stops = [stop.model_dump() for stop in user_specified_stops] if user_specified_stops else []
    
    output: Dict[str, Any] = {
        "travel_duration_requested": travel_duration,
        "base_plan": None,
        "user_specified_stops": serialized_user_stops, # Use the serialized list
        "notes": []
    }

    try:
        # Always generate the base plan using the existing algorithm
        # Pass the serialized user stops to the optimizer
        base_plan_result = optimize_distance_tour(travel_duration, user_specified_stops=serialized_user_stops)
        output["base_plan"] = base_plan_result
        output["notes"].append("A base travel plan has been generated for the specified duration.")

        if user_specified_stops: # Check original user_specified_stops for logic
            output["notes"].append(
                "The user-specified stops have been noted. "
                "Please consider them in conjunction with the base plan. "
                "Integration of these stops into a perfectly optimized route may require manual adjustment or a more advanced planning tool. "
                "For custom locations (those not in our standard Da Nang attraction database), details like precise routing or full descriptions "
                "will depend on the information you provided (e.g., address). The base plan does not automatically incorporate these custom stops."
            )
            for stop in user_specified_stops: # Iterate over original Pydantic objects for attribute access
                if stop.address:
                    output["notes"].append(f"Custom stop '{stop.name}' at address '{stop.address}' was noted. Its inclusion in the itinerary should be manually verified for location and timing.")
                else:
                    output["notes"].append(f"Specified stop '{stop.name}' was noted. Please ensure it fits well with the base plan.")
        else:
            output["notes"].append("No specific custom stops were requested for this plan.")
        
        return json.dumps(output, indent=2, ensure_ascii=False)

    except Exception as e:
        print(f"Error during trip planning: {e}")
        traceback.print_exc()
        # Ensure error_output also uses serialized stops
        error_output = {
            "error": f"Failed to generate plan: {str(e)}",
            "travel_duration_requested": travel_duration,
            "user_specified_stops": serialized_user_stops, # Use the same serialized list for consistency
            "notes": ["An error occurred during plan generation."]
        }
        return json.dumps(error_output, indent=2, ensure_ascii=False)

# --- Flight Booking Tool ---
class FlightSearchArgs(BaseModel):
    origin_city: str = Field(description="The departure city name (e.g., 'Hanoi', 'Ho Chi Minh City').")
    date_str: str = Field(description="The desired departure date. Accepts formats like 'DD/MM/YYYY', 'Month DD, YYYY' (e.g., '19/04/2025', 'April 19, 2025'), or 'Month DD' (e.g., 'May 12'). If the year is omitted from 'Month DD', it will be interpreted for the year 2025, as flight data is specific to this year.")
    # destination_city: str = Field(description="The destination city name (Optional, currently not used for filtering).", default=None) # Add if filtering becomes possible

@tool("show_flights", args_schema=FlightSearchArgs)
def show_flights_tool(origin_city: str, date_str: str) -> str:
    """
    Searches for available flights to Da Nang (DAD) from specified Vietnamese origin cities (Hanoi - HAN, Ho Chi Minh City - SGN)
    for tomorrow and the day after tomorrow in the year 2025.
    Requires the origin city and the departure date.
    It will inform the user if data for other cities or dates is not available.
    Returns flight details as a JSON string, or an error/message string.
    """
    print(f"--- Calling Flight Tool with origin: {origin_city}, date: {date_str} ---")
    try:
        # Call the flight picking service function
        flights_result = get_flights_service(origin_city=origin_city, date_str=date_str)
        
        # The service function already returns a dictionary, which can be directly converted to JSON string.
        # It handles errors by returning a dict with an 'error' or 'message' key.
        return json.dumps(flights_result, indent=2, ensure_ascii=False)
    except Exception as e:
        print(f"Error in show_flights_tool: {e}")
        traceback.print_exc()
        # Return a JSON string indicating an unexpected error in the tool itself
        return json.dumps({"error": f"An unexpected error occurred while trying to get flight information: {str(e)}"})

# --- Conceptual Tool Schema for Requesting Clarification ---
class RequestClarificationArgs(BaseModel):
    missing_parameter_name: str = Field(description="The specific piece of information that is missing from the user's query, e.g., 'travel_duration', 'flight_origin_city'.")
    original_tool_name: str = Field(description="The name of the tool that the assistant intended to use before realizing information was missing, e.g., 'plan_da_nang_trip', 'show_flights'.")

# Note: There is no @tool decorator for RequestClarificationArgs because it's not a directly executable Python function.
# It's a schema to guide the LLM when it needs to "call" the conceptual 'request_clarification_tool'.

# --- Flight Selection Tool ---
class SelectFlightArgs(BaseModel):
    selection_type: str = Field(description="The method user wants to select the flight. Can be 'ordinal' (e.g., 'first', '2nd', '3'), 'flight_id' (e.g., 'VietJet Air 1634'), or 'departure_time' (e.g., '9:05 pm', '5am').")
    selection_value: str = Field(description="The specific value corresponding to the selection_type. For 'ordinal', the number or word. For 'flight_id', the flight identifier. For 'departure_time', the time string.")
    # available_flights will be passed by the agent from its state, not directly by the LLM.

# This is a wrapper. The actual call to select_flight_for_booking will happen in the agent's
# take_action method, which will retrieve available_flights from state.
# The LLM will invoke this tool with selection_type and selection_value.
# The result from select_flight_for_booking will be structured by take_action.
# So this tool function itself doesn't need to do much other than exist for the LLM.
# However, to make it a valid tool that can be 'invoked' even if its result is
# re-interpreted/augmented by take_action, it needs to run.
# We'll have it return the args, which take_action will use.

@tool("select_flight_tool", args_schema=SelectFlightArgs)
def select_flight_tool_func(selection_type: str, selection_value: str) -> str:
    """
    Use this tool when the user has been presented with a list of flights and wants to select one.
    You need to determine how the user is trying to select the flight (by its order in the list, its flight ID, or its departure time)
    and provide the corresponding value.
    For example:
    - User: "Book the first flight." -> selection_type="ordinal", selection_value="first"
    - User: "I want flight VN123." -> selection_type="flight_id", selection_value="VN123"
    - User: "The one leaving at 9pm." -> selection_type="departure_time", selection_value="9pm"
    The actual flight selection from the previously provided list happens based on these inputs.
    This tool returns a JSON string of the selection arguments, which are then processed internally.
    """
    print(f"--- select_flight_tool_func called with type: {selection_type}, value: {selection_value} ---")
    # The agent's take_action method will handle the actual call to select_flight_for_booking
    # using these arguments and the available_flights from state.
    # This tool's direct output is more of a signal with the LLM's interpreted args.
    return json.dumps({"selection_type": selection_type, "selection_value": selection_value, "message": "Selection parameters captured for processing."})

# Add more tools as needed (e.g., search_activities, check_weather, schedule_event)

